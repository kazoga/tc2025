# obstacle_monitor 追加実装検討報告書

## 1. 目的
`obstacle_monitor` ノードに対して、以下の2点の機能拡張を行うための下調べ結果と設計方針を整理する。

- **A. obstacle_avoidance_hint メッセージへの距離情報の追加**
- **B. viewer に表示する情報の追加**

## 2. 現行実装の整理
### 2.1 メッセージ定義
`route_msgs/msg/ObstacleAvoidanceHint.msg` は `front_blocked` と左右のオープンスペース量のみを保持する。【F:ros2_src/route_msgs/msg/ObstacleAvoidanceHint.msg†L1-L8】

### 2.2 obstacle_monitor ノード
- `/scan` を購読し、LiDAR 点群を `numpy` へ変換した後に前方 ±90° へ絞り込む。【F:ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py†L74-L129】
- `max_obstacle_distance_m` 以内の点群を左右に分割し、ギャップ検出で左右の回避オフセットを算出する。【F:ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py†L118-L164】
- 前方閉塞判定 `_is_front_blocked()` はロボット幅帯内の `x` 座標の下位パーセンタイルを用いて停止距離と比較している。【F:ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py†L170-L210】
- ヒント Publish 部は `ObstacleAvoidanceHint` に左右オフセットだけを格納して送信する。【F:ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py†L212-L225】
- Viewer (`_publish_scan_image`) はロボット幅ライン・最大障害物距離ライン・点群・左右オフセットラインを描画している。【F:ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py†L227-L320】

### 2.3 down-stream 依存
`route_follower` ノードが `/obstacle_avoidance_hint` を購読し、`HintSample` に変換して `FollowerCore` へ引き渡す。`HintSample` は現状 `front_blocked / left_open / right_open` のみを保持する。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L92-L160】【F:ros2_src/route_follower/route_follower/follower_core.py†L40-L110】

## 3. 追加機能A: 距離情報の追加
### 3.1 想定仕様
- `ObstacleAvoidanceHint.msg` に新たな `float32 front_range` フィールドを追加する。
  - 「正面の最短距離」を簡潔に示すために `front_range` へ名称を整理し、冗長な単語の重複を避ける。
- 距離算出は `_is_front_blocked()` と同じ帯域判定ロジックを用い、計算は `laser_scan_callback()` 内で実行する。
- 既存の閉塞判定・左右オフセット算出を制御するパラメータ（`max_obstacle_distance_m` 等）を残しつつ、距離算出の対象範囲を独自に調整できるパラメータ（例: `hint_range_m`）を追加する。
  - 設定値の役割を一語で表すため `hint_range_m` とし、距離/レンジの重複表現を避ける。
  - 運用上は「距離算出対象範囲 ≧ 障害物とオフセットを通知する範囲」となるよう調整し、閉塞判定に使う距離パラメータより狭くならない設定を基本とする。
  - この値は `_is_front_blocked()` で得られた最近傍距離が「ヒントとして意味のある範囲内か」を判定するために使用する。
  - 範囲外であればメッセージには無効値として `float('inf')` を格納し、利用側が明確に判断できるようにする。
- `_is_front_blocked()` は「閉塞判定」と「最近傍距離（パーセンタイル値）」の両方を返却できるようリファクタリングする。
  - 既存の bool 戻り値を維持するために、関数を `Tuple[bool, float]` 返却へ変更するか、ラッパー関数を用意する。
- `ObstacleMonitorNode._publish_hint()` を更新し、新フィールドを設定する。
- `route_follower` 側では `HintSample` と `update_hint()` の呼び出しを拡張し、距離情報を保持・統計処理できるようにする（距離を利用しない場合も後方互換のために値を保持しておく）。

### 3.2 実装ポイント
1. **メッセージパッケージ更新**
   - `ObstacleAvoidanceHint.msg` の変更に合わせて `route_msgs` の `CMakeLists.txt` と `package.xml` の依存解決は変わらないが、ビルド後に `rosidl` によるコード生成が必要となる。
2. **obstacle_monitor の更新**
   - `_is_front_blocked()` を距離値を返す形に改修し、`laser_scan_callback()` で距離ヒントを受け取る。
   - 新規パラメータ `hint_range_m`（仮称）を `declare_parameter()` で登録し、初期値は `max_obstacle_distance_m` と同値を設定しておく。
   - 距離が範囲内 → `msg.front_range` に格納、範囲外 → `float('inf')` を格納。
   - Viewer 描画用に最新距離値をメンバ変数へ保持する（B項で活用）。
3. **route_follower の更新**
   - `ObstacleAvoidanceHint` 受信処理で `front_range` を取得し、`HintSample` データクラスへフィールド追加。
   - 初期段階では距離値を最新1件として保持し、`FollowerCore.update_hint()` からそのまま渡す。統計処理は拡張需要が高まった際に追加する。

## 4. 追加機能B: Viewer 表示の拡充
### 4.1 要求整理
1. **距離算出の対象範囲を示す横線**
   - 常に画像下端中央が自己位置の原点であり、上方向が前方という既存仕様を踏襲する。
   - パラメータ `hint_range_m` を可視化する水平線を描画する。
2. **障害物までの距離を示す横線**
   - 最新ヒント距離値に応じて水平線を描画。範囲外（無効値）の場合は描画しない運用とし、viewer 側では `math.isfinite()` 判定で描画可否を切り替える。
3. **active_target の位置のプロット**
   - 新たに `/active_target`（`route_follower` が `geometry_msgs/PoseStamped` で Publish）と `/amcl_pose` を購読。
   - 画像下端中央かつ鉛直上向きが `amcl_pose` の姿勢と仮定し、`active_target` をロボットローカル座標へ変換してプロット。
   - マーカー（例: 円または十字）を描画。画像外に位置する場合でも座標計算は継続。
4. **現在位置と active_target を結ぶ直線**
   - 画像範囲内に描画可能な部分のみ描く。マーカーが画像外であっても画面端まで線分を延長する。

### 4.2 既存コードへの影響
- `_publish_scan_image()` は現状、LiDAR 点群と回避ラインのみを描画しているため、以下を追加する。
   - 距離範囲ライン・距離ヒントラインの座標計算（縦方向ピクセル位置 = `height - int(distance * pixel_pitch)`）。
   - Active target の座標計算には `amcl_pose` の yaw を使用し、`goal_in_robot = R_z(-yaw) * (goal - amcl)` でロボット座標へ変換する。結果を画素へマッピングする際は既存の `x→下方向, y→左右` の写像を再利用する。
   - 線分のクリッピング処理は `cv2.clipLine()` などを活用して画像境界に制限する。
- 新規購読データを保持するため、`ObstacleMonitorNode` に以下のメンバーを追加。
  - `self._latest_front_range: Optional[float]`
  - `self._hint_range_m: float`
  - `self._goal_pose: Optional[PoseStamped]`
  - `self._amcl_pose: Optional[PoseWithCovarianceStamped]`
- 購読コールバックで最新値を更新し、`laser_scan_callback()` の最後に `_publish_scan_image()` 呼び出しへ渡す。

### 4.3 トピックと QoS
- `/active_target` は `route_follower` が `geometry_msgs/PoseStamped` を `qos_volatile()`（`ReliabilityPolicy.RELIABLE` / `DurabilityPolicy.VOLATILE` / `HistoryPolicy.KEEP_LAST(depth=10)`）で Publish しており、`republish_target_hz=1.0` に従って最長1秒周期で再送される。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L25-L104】【F:ros2_src/route_follower/route_follower/follower_core.py†L90-L117】
- `/amcl_pose` は `PoseWithCovarianceStamped` で配信されており、`obstacle_monitor` 側でも同型で購読するのが一貫している。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L83-L188】

## 5. 想定する変更ファイル一覧
- `ros2_src/route_msgs/msg/ObstacleAvoidanceHint.msg`
- `ros2_src/obstacle_monitor/obstacle_monitor/obstacle_monitor_node.py`
- `ros2_src/obstacle_monitor/package.xml` / `setup.py`（依存は変わらない見込み）
- `ros2_src/route_follower/route_follower/route_follower_node.py`
- `ros2_src/route_follower/route_follower/follower_core.py`
- その他、ビルド成果物やテスト設定に応じて補助的な修正が必要になる可能性がある。

## 6. テスト観点
1. **メッセージ互換性**: `colcon build` で `route_msgs` および依存ノードのビルドが通ること。
2. **距離ヒント**: シミュレータで障害物距離が範囲内・範囲外のケースを用意し、`/obstacle_avoidance_hint` に期待値が載ることを `ros2 topic echo` で確認する。
3. **viewer 描画**: 追加した水平線・マーカーが期待どおり描画されることをスクリーンショットで確認する。
4. **route_follower 連携**: 拡張後の `HintSample` が問題なく統計処理され、従来機能が退行しないこと。

## 7. 今後のタスク
現時点では追加タスクを設定しない。距離算出は従来どおり `_is_front_blocked()` で用いているパーセンタイル手法を正式に採用し、再評価は不要と判断した。

## 8. 曖昧点と仕様決定の整理
本節では、検討段階で残っていた曖昧点への対応方針と、追加確認事項を取りまとめる。

1. **距離ヒントの無効値**  
   Viewer など利用側の判定を簡潔にするため、距離ヒントが有効範囲外のときは `float('inf')` を格納する。`math.isfinite()` で有効性判定でき、負値特別扱いが不要になる。

2. **`_is_front_blocked()` のインターフェース**  
   本関数の戻り値を `Tuple[bool, float]`（閉塞フラグと距離パーセンタイル値）へ変更し、既存の呼び出し側でアンパックする。後方互換が必要な箇所には薄いラッパー関数（`_is_front_blocked_only()` など）を用意する運用とする。

3. **`hint_range_m` の初期値**
   デフォルトは `max_obstacle_distance_m` と同値を設定し、起動直後から「距離算出範囲 ≧ 障害物通知範囲」の運用条件を満たすようにする。YAML 等で個別調整する場合も、この条件を逸脱しないようドキュメントに明記する。

4. **`route_follower` での距離統計処理**
   初期実装では距離値をそのまま `HintSample` に保持し、`FollowerCore` へ最新値を渡すのみとする。追加の統計処理は必要性が明確になった段階で拡張する段階的運用を採用する。

5. **`/active_target` の QoS と更新頻度**
   現行の `route_follower` は `/active_target` を `qos_volatile()`（`ReliabilityPolicy.RELIABLE` / `DurabilityPolicy.VOLATILE` / `HistoryPolicy.KEEP_LAST(depth=10)`）で publish し、`republish_target_hz=1.0` に基づき最長1秒周期で再送している。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L25-L104】【F:ros2_src/route_follower/route_follower/follower_core.py†L90-L117】
   `obstacle_monitor` 側の購読も同一 QoS 設定を使用し、1Hz 程度の更新前提で viewer 描画のホールド時間を設計する。

6. **距離算出範囲パラメータの下限扱い**
   起動時に `hint_range_m < max_obstacle_distance_m` が設定された場合は、`max_obstacle_distance_m` へ自動的に丸めた上で警告ログを出力する。これにより通知範囲より狭い距離ヒントが生成されることを防ぎ、運用ルール「距離算出対象範囲 ≧ 通知範囲」を機械的に担保する。

7. **距離ヒント無効時の viewer 描画方針**
   無効値（`float('inf')`）を受け取った場合は距離ラインを描画しない。凡例や色分けなどの追加表現は行わず、`math.isfinite()` 判定により描画有無のみを切り替える。
