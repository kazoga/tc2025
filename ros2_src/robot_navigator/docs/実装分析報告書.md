# robot_navigator / route_follower 実装分析報告書

## 1. 調査対象の概要
robot_navigator パッケージには、制御ノード `robot_navigator` とシミュレータノード `robot_simulator` の2つが収録されており、差動二輪ロボットの移動制御とシミュレーションを協調して行う構成になっている。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L55-L156】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L68-L141】
これらは `/cmd_vel`・`/amcl_pose`・`/odom` 等の基本トピックを介して双方向に連携し、さらに route_follower パッケージが出力する経路追従目標 `/active_target` と状態通知 `/follower_state` を利用して自律走行シナリオを実現する設計である。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L91-L228】

## 2. ノード実装の詳細
### 2.1 robot_navigator ノード
- **パラメータと初期化**: 最大速度・加速度、位置/姿勢許容誤差、レーザセンサの検出範囲、障害物距離モードなどを ROS パラメータとして宣言し、初期化時に取得して内部変数へ格納する。通信トピックはノード内で相対名を既定化し、launch の remap で接続先を切り替える構成に統一した。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L64-L186】
- **通信インタフェース**: `/cmd_vel` 出力用 Publisher と、進行方向可視化の `/direction_marker` Publisher を保持。入力は `/odom`・`/amcl_pose`・`/active_target`・`/scan`（または `obstacle_avoidance_hint`）を購読して速度・現在姿勢・目標姿勢・障害物距離を更新する。制御周期は `control_rate_hz`（既定20Hz）でタイマー駆動される。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L140-L336】
- **障害物検出**: `/scan` からロボット前方矩形領域の最短距離を計算し、障害物距離として保持する。無効レンジのフィルタリングや矩形条件判定が実装されている。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L232-L273】
- **制御ロジック**: 角速度は PID（ゲインは旧実装継承）で算出、線速度は角度誤差をもとにスケーリングしつつ加速度上限制御と障害物距離による減速・停止を行う。障害物で前進を止めた場合でも `ang_tol` 以内に収束するまでは角速度指令を維持し、その場旋回でウェイポイントへ向き直す。ゴール到達判定で両速度を0にし、安全のため入力不足時は停止指令を出す。また進行方向を Marker で可視化し、必要に応じて CSV ログへ計測値を書き出す。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L283-L383】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L218-L255】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L383-L433】
- **目標監視ログ**: `/active_target` を1秒周期で監視し、受信できていない場合は待機理由を、現在姿勢が得られた場合はターゲットのXY座標と距離、さらに現在姿勢との角度誤差（度数法）を INFO ログで通知する。距離許容値内では目標ヨー角との差を、未到達時はターゲット位置へのベアリング差を用いて角度誤差を算出する。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L327-L357】

### 2.2 robot_simulator ノード
- **役割とパラメータ**: `/cmd_vel` を受け取り差動二輪運動学で状態を積分し、`/odom`・`/amcl_pose`・`/tf` を出力する。更新周期、速度上限、初期姿勢、ノイズ、タイムアウト等をパラメータ化している。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L3-L149】
- **初期座標系の決定**: `/active_target` を初回受信するまでシミュレータの更新・配信処理を開始せず、1秒おきに待機ログを INFO で出力する。初回メッセージを受け取ると既存のオドメトリ状態を保ったまま map→odom 変換を調整し、/active_target で提示された姿勢と `/amcl_pose` の初期値が厳密に一致するよう原点を定める。その後は `/amcl_pose` を購読して原点の再取得にも対応する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L151-L272】
- **運動と配信**: 初期化完了後は一定周期で速度を積分し、タイムアウト時には自動停止。一定間隔で Odometry・AMCL Pose・TF を送信し、必要に応じてノイズを付与する。`/cmd_vel` が上限を超える場合は警告付きで飽和させる実装が含まれる。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L164-L306】

## 3. route_follower ノードと FollowerCore の連携ポイント
- route_follower ノードは Core ロジック `FollowerCore` をラップし、`/active_route`・`/amcl_pose`・`/obstacle_avoidance_hint` 等を購読しながら内部状態を更新する。Core から得た最新ターゲット姿勢は PoseStamped として `/active_target` に発行し、追従状態を `/follower_state` に公開する。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L78-L228】
- `FollowerCore` はルート waypoint、現在姿勢、障害回避ヒントを mailbox 方式で受け取り、`tick()`（20Hz想定）で到達判定・滞留検知・障害回避サブゴール生成を行う。滞留発生時にはステータスを `WAITING_REROUTE` に遷移し、Node 側から `/report_stuck` サービスが呼ばれる仕組みである。【F:ros2_src/route_follower/route_follower/follower_core.py†L3-L184】【F:ros2_src/route_follower/route_follower/route_follower_node.py†L174-L257】
- Core は `arrival_threshold` や `reroute_timeout_sec` 等の閾値を持ち、回避サブゴールキューや滞留履歴を管理することで目標姿勢を生成する。これにより navigator が逐次追従すべき Pose を `/active_target` として受け取れるようになる。【F:ros2_src/route_follower/route_follower/follower_core.py†L102-L184】

## 4. ノード間の連携シーケンス
1. route_manager / planner 等から `/active_route` が配信されると、route_follower が内部ルートを更新し、`tick()` 実行ごとに現在位置とヒントをもとに進行中 waypoint を選択する。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L115-L199】
2. route_follower は必要に応じて `/active_target` を PoseStamped で再送し、滞留検知に応じて `/report_stuck` を呼び出す。ステータスは `/follower_state` に反映される。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L257】
3. robot_navigator は `/amcl_pose` と `/active_target`（launch の remap でトピック変更可能）を購読し、姿勢・目標が揃えば PID/障害物判定で `/cmd_vel` を出力する。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L140-L381】【F:ros2_src/robot_navigator/launch/robot_navigator.launch.py†L1-L90】
4. robot_simulator は `/active_target` を受けて初期化を完了したあと `/cmd_vel` を取り込み、内部状態を更新して `/odom`・`/amcl_pose`・`/tf` を配信し、navigator と route_follower の入力（現在姿勢）を継続的に供給する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L124-L285】

この循環により、route_follower → robot_navigator → robot_simulator → route_follower のループが形成され、自律走行を模擬できる。

## 5. 連携上の懸念・問題点
1. **`/active_target` 連携の義務化**: robot_simulator は PoseStamped を `/active_target` から必ず受信する設計に統一され、初期化前は `/cmd_vel` を無視して出力も停止したまま待機する。これにより route_follower が提示するターゲット姿勢とシミュレーション座標系の不整合が発生しない。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L132-L226】【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L211】
2. **目標トピック名の初期設定差異**: robot_navigator は内部で `active_target` という相対名を既定化し、launch の remap で `/active_target` など任意の名称へ接続できる。警告メッセージもリマップ後の名称を参照するため、トピック変更時にログ表記との不整合が発生しない。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L162-L336】【F:ros2_src/robot_navigator/launch/robot_navigator.launch.py†L1-L90】
3. **初期化待ち運用時の注意**: `/active_target` が遅延する場合、robot_simulator は INFO ログで待機状況を通知するのみで出力を行わないため、上流ノードがターゲットを供給できる状態かを監視する運用が必要である。ターゲットが到着すれば自動で初期化が完了し、その後は従来どおりの制御ループが成立する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L207-L226】
4. **`/amcl_pose` フィードバックの循環防止**: `/amcl_pose` を同じノードが publish/subscribe しているため、自ノードが送信した PoseWithCovarianceStamped を即座に受信し、原点更新ロジックが毎周期その値を map→odom 原点として積み増す挙動が発生した。直前に送信したメッセージのタイムスタンプを保持し、同じ値を持つ受信メッセージを無視することで外部ノードからの再初期化指示のみに反応するようガードした。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L113-L117】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L178-L184】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L243-L272】
5. **初期化直後の距離が大きくなる問題**: `/active_target` を取り込んだ際にオドメトリ状態そのものを目標座標へ書き換えていたため、map→odom 変換でも同じ座標が加算され、初回 `/amcl_pose` が目標の約2倍離れた値として配信されていた。/active_target を受信した時点でオドメトリ姿勢を保持しつつ原点変換だけを調整するよう改修することで、初回ログから距離が0m近傍で始まり以降も正しい距離計算が継続するようになった。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L188-L272】
6. **ウェイポイント通過後に距離が増大する問題**: ゴール判定前でも目標 Pose のヨー角をそのまま角度誤差として用いていたため、ウェイポイントを通過するとロボットが振り返らず直進し続け、距離ログが単調増加する現象が起きていた。旧ROS1実装と同じく、位置到達前は目標位置へのベアリングを用いて方向誤差を計算し、所定距離内に入った時点でのみ目標ヨー角との整合を図るよう修正したことで、Sawtooth 状の距離変化が継続するようになった。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L333-L360】

## 6. 再調査の着眼点と結果
- **購読/配信 QoS の整合性確認**: route_follower の `/active_target` Publisher は RELIABLE/VOLATILE で、robot_navigator の購読 QoS 10 (デフォルト RELIABLE) と整合している。robot_simulator が `/cmd_vel` を購読する QoS も深さ10で、navigator の Publisher と同条件であるため、再送やロストのリスクは最小限と判断した。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L91-L210】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L139-L210】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L96-L170】
- **目標トピック経路の通し確認**: route_follower → `/active_target` → robot_navigator → `/cmd_vel` → robot_simulator の流れをコード上で再追跡し、いずれも PoseStamped と Twist に統一されていることを確認した。robot_simulator の初期姿勢取得も PoseStamped 購読へ改修されたため、経路追従のデータ経路全体で型不整合は解消されている。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L257】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L148-L327】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L124-L220】
- **停止処理の挙動確認**: 入力欠損時の停止処理は `/amcl_pose` `/odom` `active_target` のリマップ後名称を WARN ログに含め、ゼロ Twist を発行する構成である。これによりトピック名変更後もオペレータが不足入力を正しく把握でき、安全停止も維持されることを確認した。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L162-L336】

## 7. まとめ
robot_navigator と robot_simulator は差動二輪ロボットの移動制御とシミュレーションを ROS2 上で完結させるためのペアノードであり、route_follower が生成する目標姿勢を取り込むことで経路追従ワークフローを構成できる。しかし、目標トピックとメッセージ型の差異など、協調動作を阻害し得る実装上のギャップが存在するため、連携利用時には設定・実装の見直しが不可欠である。
