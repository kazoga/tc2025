# robot_navigator / route_follower 実装分析報告書

## 1. 調査対象の概要
robot_navigator パッケージには、制御ノード `robot_navigator` とシミュレータノード `robot_simulator` の2つが収録されており、差動二輪ロボットの移動制御とシミュレーションを協調して行う構成になっている。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L55-L156】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L68-L141】
これらは `/cmd_vel`・`/amcl_pose`・`/odom` 等の基本トピックを介して双方向に連携し、さらに route_follower パッケージが出力する経路追従目標 `/active_target` と状態通知 `/follower_state` を利用して自律走行シナリオを実現する設計である。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L91-L228】

## 2. ノード実装の詳細
### 2.1 robot_navigator ノード
- **パラメータと初期化**: 最大速度・加速度、位置/姿勢許容誤差、レーザセンサの検出範囲、障害物距離モードなどを ROS パラメータとして宣言し、初期化時に取得して内部変数へ格納する。通信トピックはノード内で相対名を既定化し、launch の remap で接続先を切り替える構成に統一した。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L64-L186】
- **通信インタフェース**: `/cmd_vel` 出力用 Publisher と、進行方向可視化の `/direction_marker` Publisher を保持。入力は `/odom`・`/amcl_pose`・`/active_target`・`/scan`（または `obstacle_avoidance_hint`）を購読して速度・現在姿勢・目標姿勢・障害物距離を更新する。制御周期は `control_rate_hz`（既定20Hz）でタイマー駆動される。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L140-L336】
- **障害物検出**: `/scan` からロボット前方矩形領域の最短距離を計算し、障害物距離として保持する。無効レンジのフィルタリングや矩形条件判定が実装されている。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L232-L273】
- **制御ロジック**: 角速度は PID（ゲインは旧実装継承）で算出、線速度は角度誤差をもとにスケーリングしつつ加速度上限制御と障害物距離による減速・停止を行う。障害物で前進を止めた場合でも `ang_tol` 以内に収束するまでは角速度指令を維持し、その場旋回でウェイポイントへ向き直す。ゴール到達判定で両速度を0にし、安全のため入力不足時は停止指令を出す。また進行方向を Marker で可視化し、必要に応じて CSV ログへ計測値を書き出す。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L283-L383】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L218-L255】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L383-L433】
- **目標監視ログ**: `/active_target` を1秒周期で監視し、受信できていない場合は待機理由を、現在姿勢が得られた場合はターゲットのXY座標と距離、さらに現在姿勢との角度誤差（度数法）を INFO ログで通知する。距離許容値内では目標ヨー角との差を、未到達時はターゲット位置へのベアリング差を用いて角度誤差を算出する。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L327-L357】

### 2.2 robot_simulator ノード
- **役割とパラメータ**: `/cmd_vel` を受け取り差動二輪運動学で状態を積分し、`/odom`・`/amcl_pose`・`/tf` を出力する。更新周期、速度上限、初期姿勢、ノイズ、タイムアウト等をパラメータ化している。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L3-L149】
- **初期座標系の決定**: `/active_target` を初回受信するまでシミュレータの更新・配信処理を開始せず、1秒おきに待機ログを INFO で出力する。初回メッセージを受け取ると既存のオドメトリ状態を保ったまま map→odom 変換を調整し、/active_target で提示された姿勢と `/amcl_pose` の初期値が厳密に一致するよう原点を定める。その後は `/amcl_pose` を購読して原点の再取得にも対応する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L151-L272】
- **運動と配信**: 初期化完了後は一定周期で速度を積分し、タイムアウト時には自動停止。一定間隔で Odometry・AMCL Pose・TF を送信し、必要に応じてノイズを付与する。`/cmd_vel` が上限を超える場合は警告付きで飽和させる実装が含まれる。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L164-L306】

## 3. route_follower ノードと FollowerCore の連携ポイント
- route_follower ノードは Core ロジック `FollowerCore` をラップし、`/active_route`・`/amcl_pose`・`/obstacle_avoidance_hint` 等を購読しながら内部状態を更新する。Core から得た最新ターゲット姿勢は PoseStamped として `/active_target` に発行し、追従状態を `/follower_state` に公開する。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L78-L228】
- `FollowerCore` はルート waypoint、現在姿勢、障害回避ヒントを mailbox 方式で受け取り、`tick()`（20Hz想定）で到達判定・滞留検知・障害回避サブゴール生成を行う。滞留発生時にはステータスを `WAITING_REROUTE` に遷移し、Node 側から `/report_stuck` サービスが呼ばれる仕組みである。【F:ros2_src/route_follower/route_follower/follower_core.py†L3-L184】【F:ros2_src/route_follower/route_follower/route_follower_node.py†L174-L257】
- Core は `arrival_threshold` や `reroute_timeout_sec` 等の閾値を持ち、回避サブゴールキューや滞留履歴を管理することで目標姿勢を生成する。これにより navigator が逐次追従すべき Pose を `/active_target` として受け取れるようになる。【F:ros2_src/route_follower/route_follower/follower_core.py†L102-L184】

## 4. ノード間の連携シーケンス
1. route_manager / planner 等から `/active_route` が配信されると、route_follower が内部ルートを更新し、`tick()` 実行ごとに現在位置とヒントをもとに進行中 waypoint を選択する。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L115-L199】
2. route_follower は必要に応じて `/active_target` を PoseStamped で再送し、滞留検知に応じて `/report_stuck` を呼び出す。ステータスは `/follower_state` に反映される。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L257】
3. robot_navigator は `/amcl_pose` と `/active_target`（launch の remap でトピック変更可能）を購読し、姿勢・目標が揃えば PID/障害物判定で `/cmd_vel` を出力する。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L140-L381】【F:ros2_src/robot_navigator/launch/robot_navigator.launch.py†L1-L90】
4. robot_simulator は `/active_target` を受けて初期化を完了したあと `/cmd_vel` を取り込み、内部状態を更新して `/odom`・`/amcl_pose`・`/tf` を配信し、navigator と route_follower の入力（現在姿勢）を継続的に供給する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L124-L285】

この循環により、route_follower → robot_navigator → robot_simulator → route_follower のループが形成され、自律走行を模擬できる。

## 5. 連携上の懸念・問題点
1. **`/active_target` 連携の義務化**: robot_simulator は PoseStamped を `/active_target` から必ず受信する設計に統一され、初期化前は `/cmd_vel` を無視して出力も停止したまま待機する。これにより route_follower が提示するターゲット姿勢とシミュレーション座標系の不整合が発生しない。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L132-L226】【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L211】
2. **目標トピック名の初期設定差異**: robot_navigator は内部で `active_target` という相対名を既定化し、launch の remap で `/active_target` など任意の名称へ接続できる。警告メッセージもリマップ後の名称を参照するため、トピック変更時にログ表記との不整合が発生しない。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L162-L336】【F:ros2_src/robot_navigator/launch/robot_navigator.launch.py†L1-L90】
3. **初期化待ち運用時の注意**: `/active_target` が遅延する場合、robot_simulator は INFO ログで待機状況を通知するのみで出力を行わないため、上流ノードがターゲットを供給できる状態かを監視する運用が必要である。ターゲットが到着すれば自動で初期化が完了し、その後は従来どおりの制御ループが成立する。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L207-L226】
4. **`/amcl_pose` フィードバックの循環防止**: `/amcl_pose` を同じノードが publish/subscribe しているため、自ノードが送信した PoseWithCovarianceStamped を即座に受信し、原点更新ロジックが毎周期その値を map→odom 原点として積み増す挙動が発生した。直前に送信したメッセージのタイムスタンプを保持し、同じ値を持つ受信メッセージを無視することで外部ノードからの再初期化指示のみに反応するようガードした。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L113-L117】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L178-L184】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L243-L272】
5. **初期化直後の距離が大きくなる問題**: `/active_target` を取り込んだ際にオドメトリ状態そのものを目標座標へ書き換えていたため、map→odom 変換でも同じ座標が加算され、初回 `/amcl_pose` が目標の約2倍離れた値として配信されていた。/active_target を受信した時点でオドメトリ姿勢を保持しつつ原点変換だけを調整するよう改修することで、初回ログから距離が0m近傍で始まり以降も正しい距離計算が継続するようになった。【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L188-L272】
6. **ウェイポイント通過後に距離が増大する問題**: ゴール判定前でも目標 Pose のヨー角をそのまま角度誤差として用いていたため、ウェイポイントを通過するとロボットが振り返らず直進し続け、距離ログが単調増加する現象が起きていた。旧ROS1実装と同じく、位置到達前は目標位置へのベアリングを用いて方向誤差を計算し、所定距離内に入った時点でのみ目標ヨー角との整合を図るよう修正したことで、Sawtooth 状の距離変化が継続するようになった。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L333-L360】

## 6. 再調査の着眼点と結果
- **購読/配信 QoS の整合性確認**: route_follower の `/active_target` Publisher は RELIABLE/VOLATILE で、robot_navigator の購読 QoS 10 (デフォルト RELIABLE) と整合している。robot_simulator が `/cmd_vel` を購読する QoS も深さ10で、navigator の Publisher と同条件であるため、再送やロストのリスクは最小限と判断した。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L91-L210】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L139-L210】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L96-L170】
- **目標トピック経路の通し確認**: route_follower → `/active_target` → robot_navigator → `/cmd_vel` → robot_simulator の流れをコード上で再追跡し、いずれも PoseStamped と Twist に統一されていることを確認した。robot_simulator の初期姿勢取得も PoseStamped 購読へ改修されたため、経路追従のデータ経路全体で型不整合は解消されている。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L188-L257】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L148-L327】【F:ros2_src/robot_navigator/robot_navigator/robot_simulator_node.py†L124-L220】
- **停止処理の挙動確認**: 入力欠損時の停止処理は `/amcl_pose` `/odom` `active_target` のリマップ後名称を WARN ログに含め、ゼロ Twist を発行する構成である。これによりトピック名変更後もオペレータが不足入力を正しく把握でき、安全停止も維持されることを確認した。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L162-L336】

## 7. まとめ
robot_navigator と robot_simulator は差動二輪ロボットの移動制御とシミュレーションを ROS2 上で完結させるためのペアノードであり、route_follower が生成する目標姿勢を取り込むことで経路追従ワークフローを構成できる。しかし、目標トピックとメッセージ型の差異など、協調動作を阻害し得る実装上のギャップが存在するため、連携利用時には設定・実装の見直しが不可欠である。

## 8. road_blocked 解除シーケンスの実装検討
### 8.1 ノード実装の現状整理
- **robot_navigator**: `/road_blocked` の Bool を受信すると `_road_block_active` を立て、`road_block_hold_sec`（既定5秒）だけ強制停止する。`road_blocked=False` を受信した場合は hold を延長したうえで解除候補として取り込み、`_road_block_release_candidate_*` を更新することで active_target の stamp 変化がなくても hold 満了後に走行を再開できる。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L136-L209】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L287-L338】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L390-L449】
- **road_blockage_detector_node**: YOLO 検知の割合が `decision_frame_ratio` 以上になると即座に `/road_blocked=True` を出し、その後 `confirmation_duration`（既定10秒）続いた時点で封鎖地点を記録する。検知割合が閾値を下回れば一時判定を破棄し、`/road_blocked=False` を即時通知するため誤検知を取り下げる動作が実装済みである。【F:ros2_src/yolo_detector/yolo_detector/road_blockage_detector_node.py†L18-L116】【F:ros2_src/yolo_detector/yolo_detector/road_blockage_detector_node.py†L200-L243】【F:ros2_src/yolo_detector/yolo_detector/road_blockage_detector_node.py†L300-L320】
- **route_follower / FollowerCore**: `/road_blocked` を Volatile 購読し、最新値と受信時刻を mailbox に保持する。滞留判定は猶予2秒後に開始し、`stagnation_duration_sec` 15秒以上の停滞を検出したうえで `road_blocked_confirmation_sec`（既定5秒）以上 True が継続した場合のみ road_blocked を最優先理由として `WAITING_REROUTE` へ遷移する。新ルート適用時に road_blocked のラッチは破棄されるため、誤検知が短時間で解除されれば reroute を避けられる。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L120-L174】【F:ros2_src/route_follower/route_follower/follower_core.py†L136-L214】【F:ros2_src/route_follower/route_follower/follower_core.py†L496-L569】

### 8.2 想定される問題シナリオ
- 誤検知から数秒後に `road_blocked=False` が撤回通知として届いても、robot_navigator は active_target 変更が来るまで強制停止を継続するため、route_follower が新目標を再送しない限り走行再開ができない。
- robot_navigator の強制停止時間（既定5秒）は route_follower の滞留検知開始（2秒経過後）より長いが、滞留確定には15秒必要なため即座に reroute には入らない。ただし active_target 再送がない環境では、誤検知解除後も navigator が静止し続け、15秒経過で route_follower が road_blocked 理由で `WAITING_REROUTE` に入る恐れがある。

### 8.3 解除ロジック拡張の提案
1. **`road_blocked=False` を navigator の解除候補に昇格させる**: `on_road_blocked(False)` 受信時に `_road_block_release_candidate_sequence` と `_road_block_release_candidate_route_version` を現在値で更新し、`road_block_hold_sec` 経過後は active_target 変化なしでも `_should_stop_due_to_road_block()` が解除可能とする。header.stamp を保持する既存の仕組みを流用して、`_road_block_release_candidate_stamp` に直前の `_last_goal_stamp` をセットすれば、False 受信が停止解除に使われる一方でゴール未受信時の誤解除も防げる。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L287-L338】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L390-L498】
2. **最小停止時間の維持とフラッタ抑制**: 上記拡張でも `_road_block_stop_until` を尊重することで決め打ち停止時間（例:5秒）は守られ、`road_blockage_detector` が閾値付近で揺れる場合でも連続 False 受信がそのまま即解除になるのを防げる。必要に応じて False 受信からのデバウンス時間を追加で設ける。
3. **route_follower との整合**: route_follower は road_blocked の最新値を Snapshot で扱うだけなので、False を受け取れば滞留時の reroute トリガも無効化される。navigator 側の解除が早まっても、`stagnation_duration_sec` 15秒の条件があるため滞留誤検知とは競合しない。active_target の再送が無い環境でも、上記 False 解除で自律的に再走行できる。
4. **封鎖確定時の安全策**: `road_blockage_detector` は10秒継続で封鎖地点を記録するため、この時間を超えて True が続くケースでは従来どおり route_follower 側の reroute（`WAITING_REROUTE` → `report_stuck`）に委ね、navigator の解除条件を active_target 更新必須のまま残す、といった二段階の運用も検討できる。False 解除を「仮判定中のみ有効」に制限することで、真の封鎖時に早すぎる解除が起きないよう制御する。【F:ros2_src/yolo_detector/yolo_detector/road_blockage_detector_node.py†L200-L243】

### 8.4 誤検知解除タイミングにおける注意点
- **停止猶予中に False が届いた場合の解除漏れ対策**: `_road_block_stop_until` の満了後に `_road_block_release_candidate_*` を評価するようにし、True→False→（hold 中）→解除判定の順で必ず再評価されるようにする。False 受信時点で `_road_block_stop_until = max(_road_block_stop_until, now + hold)` として停止満了時刻を伸長しておけば、hold 以前に False を受け取っても満了後の評価で必ず解除に進む。一方で False 直後の即解除は発生しないため、フラッタに対する安全性も維持できる。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L287-L338】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L390-L498】
- **滞留判定との競合防止**: 停止発生から `stagnation_duration_sec`（既定15秒）で reroute に移行する route_follower に対し、navigator で road_blocked を解除しても reroute が発火しないようにするには、(1) route_follower 側で road_blocked=True の最終受信時刻を保持し、reroute 判定時に「一定時間（例:5秒）True が持続しているか」を再確認する、または (2) navigator からの解除後に `/follower_state` へ「road_blocked 解除」イベントを通知する等で滞留監視をリセットする、といった協調を追加する。これにより誤検知解除後に不要な reroute が走るリスクを低減できる。【F:ros2_src/route_follower/route_follower/route_follower_node.py†L120-L174】【F:ros2_src/route_follower/route_follower/follower_core.py†L136-L214】【F:ros2_src/route_follower/route_follower/follower_core.py†L496-L565】

上記のように False 受信を navigator の解除契機に組み込むだけで、誤検知撤回時の手動介入や active_target 再送を待たずに走行再開できる。一方で封鎖が継続する場合は現行の active_target 更新必須の設計を温存することで、確定的な reroute 流れを変えずに安全性を保てる。

### 8.5 今回実装した改善
- robot_navigator で `road_blocked=False` を解除候補として登録し、hold 満了後に
  active_target の stamp 変化なしでも走行を再開できるようにした。False 受信時
  は hold を延長してデバウンスも兼ねる。【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L287-L338】【F:ros2_src/robot_navigator/robot_navigator/robot_navigator_node.py†L390-L449】
- route_follower / FollowerCore で road_blocked を滞留理由に採用する前に
  `road_blocked_confirmation_sec`（5秒）以上の継続を確認し、誤検知の取り消しで
  reroute が走らないようにした。【F:ros2_src/route_follower/route_follower/follower_core.py†L168-L214】【F:ros2_src/route_follower/route_follower/follower_core.py†L496-L569】
